// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/clustlight/animatrix-api/ent/episode"
	"github.com/clustlight/animatrix-api/ent/predicate"
	"github.com/clustlight/animatrix-api/ent/season"
	"github.com/clustlight/animatrix-api/ent/series"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEpisode = "Episode"
	TypeSeason  = "Season"
	TypeSeries  = "Series"
)

// EpisodeMutation represents an operation that mutates the Episode nodes in the graph.
type EpisodeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	title             *string
	episode_id        *string
	episode_number    *int
	addepisode_number *int
	duration          *float64
	addduration       *float64
	duration_string   *string
	timestamp         *time.Time
	thumbnail         *string
	format_id         *string
	width             *int
	addwidth          *int
	height            *int
	addheight         *int
	dynamic_range     *string
	metadata          *string
	clearedFields     map[string]struct{}
	season            *int
	clearedseason     bool
	done              bool
	oldValue          func(context.Context) (*Episode, error)
	predicates        []predicate.Episode
}

var _ ent.Mutation = (*EpisodeMutation)(nil)

// episodeOption allows management of the mutation configuration using functional options.
type episodeOption func(*EpisodeMutation)

// newEpisodeMutation creates new mutation for the Episode entity.
func newEpisodeMutation(c config, op Op, opts ...episodeOption) *EpisodeMutation {
	m := &EpisodeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpisode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpisodeID sets the ID field of the mutation.
func withEpisodeID(id int) episodeOption {
	return func(m *EpisodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Episode
		)
		m.oldValue = func(ctx context.Context) (*Episode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Episode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpisode sets the old Episode of the mutation.
func withEpisode(node *Episode) episodeOption {
	return func(m *EpisodeMutation) {
		m.oldValue = func(context.Context) (*Episode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpisodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpisodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EpisodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EpisodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Episode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *EpisodeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EpisodeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EpisodeMutation) ResetTitle() {
	m.title = nil
}

// SetEpisodeID sets the "episode_id" field.
func (m *EpisodeMutation) SetEpisodeID(s string) {
	m.episode_id = &s
}

// EpisodeID returns the value of the "episode_id" field in the mutation.
func (m *EpisodeMutation) EpisodeID() (r string, exists bool) {
	v := m.episode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeID returns the old "episode_id" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldEpisodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeID: %w", err)
	}
	return oldValue.EpisodeID, nil
}

// ResetEpisodeID resets all changes to the "episode_id" field.
func (m *EpisodeMutation) ResetEpisodeID() {
	m.episode_id = nil
}

// SetEpisodeNumber sets the "episode_number" field.
func (m *EpisodeMutation) SetEpisodeNumber(i int) {
	m.episode_number = &i
	m.addepisode_number = nil
}

// EpisodeNumber returns the value of the "episode_number" field in the mutation.
func (m *EpisodeMutation) EpisodeNumber() (r int, exists bool) {
	v := m.episode_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeNumber returns the old "episode_number" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldEpisodeNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeNumber: %w", err)
	}
	return oldValue.EpisodeNumber, nil
}

// AddEpisodeNumber adds i to the "episode_number" field.
func (m *EpisodeMutation) AddEpisodeNumber(i int) {
	if m.addepisode_number != nil {
		*m.addepisode_number += i
	} else {
		m.addepisode_number = &i
	}
}

// AddedEpisodeNumber returns the value that was added to the "episode_number" field in this mutation.
func (m *EpisodeMutation) AddedEpisodeNumber() (r int, exists bool) {
	v := m.addepisode_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeNumber resets all changes to the "episode_number" field.
func (m *EpisodeMutation) ResetEpisodeNumber() {
	m.episode_number = nil
	m.addepisode_number = nil
}

// SetDuration sets the "duration" field.
func (m *EpisodeMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *EpisodeMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to the "duration" field.
func (m *EpisodeMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *EpisodeMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *EpisodeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetDurationString sets the "duration_string" field.
func (m *EpisodeMutation) SetDurationString(s string) {
	m.duration_string = &s
}

// DurationString returns the value of the "duration_string" field in the mutation.
func (m *EpisodeMutation) DurationString() (r string, exists bool) {
	v := m.duration_string
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationString returns the old "duration_string" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldDurationString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationString: %w", err)
	}
	return oldValue.DurationString, nil
}

// ResetDurationString resets all changes to the "duration_string" field.
func (m *EpisodeMutation) ResetDurationString() {
	m.duration_string = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *EpisodeMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EpisodeMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EpisodeMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetThumbnail sets the "thumbnail" field.
func (m *EpisodeMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *EpisodeMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldThumbnail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *EpisodeMutation) ResetThumbnail() {
	m.thumbnail = nil
}

// SetFormatID sets the "format_id" field.
func (m *EpisodeMutation) SetFormatID(s string) {
	m.format_id = &s
}

// FormatID returns the value of the "format_id" field in the mutation.
func (m *EpisodeMutation) FormatID() (r string, exists bool) {
	v := m.format_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFormatID returns the old "format_id" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldFormatID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormatID: %w", err)
	}
	return oldValue.FormatID, nil
}

// ResetFormatID resets all changes to the "format_id" field.
func (m *EpisodeMutation) ResetFormatID() {
	m.format_id = nil
}

// SetWidth sets the "width" field.
func (m *EpisodeMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *EpisodeMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *EpisodeMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *EpisodeMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *EpisodeMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *EpisodeMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *EpisodeMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *EpisodeMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *EpisodeMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *EpisodeMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetDynamicRange sets the "dynamic_range" field.
func (m *EpisodeMutation) SetDynamicRange(s string) {
	m.dynamic_range = &s
}

// DynamicRange returns the value of the "dynamic_range" field in the mutation.
func (m *EpisodeMutation) DynamicRange() (r string, exists bool) {
	v := m.dynamic_range
	if v == nil {
		return
	}
	return *v, true
}

// OldDynamicRange returns the old "dynamic_range" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldDynamicRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDynamicRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDynamicRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDynamicRange: %w", err)
	}
	return oldValue.DynamicRange, nil
}

// ResetDynamicRange resets all changes to the "dynamic_range" field.
func (m *EpisodeMutation) ResetDynamicRange() {
	m.dynamic_range = nil
}

// SetMetadata sets the "metadata" field.
func (m *EpisodeMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EpisodeMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EpisodeMutation) ResetMetadata() {
	m.metadata = nil
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *EpisodeMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *EpisodeMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *EpisodeMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *EpisodeMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *EpisodeMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *EpisodeMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the EpisodeMutation builder.
func (m *EpisodeMutation) Where(ps ...predicate.Episode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EpisodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EpisodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Episode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EpisodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EpisodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Episode).
func (m *EpisodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EpisodeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, episode.FieldTitle)
	}
	if m.episode_id != nil {
		fields = append(fields, episode.FieldEpisodeID)
	}
	if m.episode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	if m.duration != nil {
		fields = append(fields, episode.FieldDuration)
	}
	if m.duration_string != nil {
		fields = append(fields, episode.FieldDurationString)
	}
	if m.timestamp != nil {
		fields = append(fields, episode.FieldTimestamp)
	}
	if m.thumbnail != nil {
		fields = append(fields, episode.FieldThumbnail)
	}
	if m.format_id != nil {
		fields = append(fields, episode.FieldFormatID)
	}
	if m.width != nil {
		fields = append(fields, episode.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, episode.FieldHeight)
	}
	if m.dynamic_range != nil {
		fields = append(fields, episode.FieldDynamicRange)
	}
	if m.metadata != nil {
		fields = append(fields, episode.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EpisodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldTitle:
		return m.Title()
	case episode.FieldEpisodeID:
		return m.EpisodeID()
	case episode.FieldEpisodeNumber:
		return m.EpisodeNumber()
	case episode.FieldDuration:
		return m.Duration()
	case episode.FieldDurationString:
		return m.DurationString()
	case episode.FieldTimestamp:
		return m.Timestamp()
	case episode.FieldThumbnail:
		return m.Thumbnail()
	case episode.FieldFormatID:
		return m.FormatID()
	case episode.FieldWidth:
		return m.Width()
	case episode.FieldHeight:
		return m.Height()
	case episode.FieldDynamicRange:
		return m.DynamicRange()
	case episode.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EpisodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case episode.FieldTitle:
		return m.OldTitle(ctx)
	case episode.FieldEpisodeID:
		return m.OldEpisodeID(ctx)
	case episode.FieldEpisodeNumber:
		return m.OldEpisodeNumber(ctx)
	case episode.FieldDuration:
		return m.OldDuration(ctx)
	case episode.FieldDurationString:
		return m.OldDurationString(ctx)
	case episode.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case episode.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case episode.FieldFormatID:
		return m.OldFormatID(ctx)
	case episode.FieldWidth:
		return m.OldWidth(ctx)
	case episode.FieldHeight:
		return m.OldHeight(ctx)
	case episode.FieldDynamicRange:
		return m.OldDynamicRange(ctx)
	case episode.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Episode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case episode.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case episode.FieldEpisodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeID(v)
		return nil
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeNumber(v)
		return nil
	case episode.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case episode.FieldDurationString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationString(v)
		return nil
	case episode.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case episode.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case episode.FieldFormatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormatID(v)
		return nil
	case episode.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case episode.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case episode.FieldDynamicRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDynamicRange(v)
		return nil
	case episode.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EpisodeMutation) AddedFields() []string {
	var fields []string
	if m.addepisode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	if m.addduration != nil {
		fields = append(fields, episode.FieldDuration)
	}
	if m.addwidth != nil {
		fields = append(fields, episode.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, episode.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EpisodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldEpisodeNumber:
		return m.AddedEpisodeNumber()
	case episode.FieldDuration:
		return m.AddedDuration()
	case episode.FieldWidth:
		return m.AddedWidth()
	case episode.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeNumber(v)
		return nil
	case episode.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case episode.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case episode.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Episode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EpisodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EpisodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpisodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Episode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EpisodeMutation) ResetField(name string) error {
	switch name {
	case episode.FieldTitle:
		m.ResetTitle()
		return nil
	case episode.FieldEpisodeID:
		m.ResetEpisodeID()
		return nil
	case episode.FieldEpisodeNumber:
		m.ResetEpisodeNumber()
		return nil
	case episode.FieldDuration:
		m.ResetDuration()
		return nil
	case episode.FieldDurationString:
		m.ResetDurationString()
		return nil
	case episode.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case episode.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case episode.FieldFormatID:
		m.ResetFormatID()
		return nil
	case episode.FieldWidth:
		m.ResetWidth()
		return nil
	case episode.FieldHeight:
		m.ResetHeight()
		return nil
	case episode.FieldDynamicRange:
		m.ResetDynamicRange()
		return nil
	case episode.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EpisodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.season != nil {
		edges = append(edges, episode.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EpisodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case episode.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EpisodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EpisodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EpisodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseason {
		edges = append(edges, episode.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EpisodeMutation) EdgeCleared(name string) bool {
	switch name {
	case episode.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EpisodeMutation) ClearEdge(name string) error {
	switch name {
	case episode.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Episode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EpisodeMutation) ResetEdge(name string) error {
	switch name {
	case episode.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown Episode edge %s", name)
}

// SeasonMutation represents an operation that mutates the Season nodes in the graph.
type SeasonMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	season_id          *string
	season_title       *string
	season_title_yomi  *string
	season_number      *int
	addseason_number   *int
	shoboi_tid         *int
	addshoboi_tid      *int
	description        *string
	first_year         *int
	addfirst_year      *int
	first_month        *int
	addfirst_month     *int
	first_end_year     *int
	addfirst_end_year  *int
	first_end_month    *int
	addfirst_end_month *int
	clearedFields      map[string]struct{}
	series             *int
	clearedseries      bool
	episodes           map[int]struct{}
	removedepisodes    map[int]struct{}
	clearedepisodes    bool
	done               bool
	oldValue           func(context.Context) (*Season, error)
	predicates         []predicate.Season
}

var _ ent.Mutation = (*SeasonMutation)(nil)

// seasonOption allows management of the mutation configuration using functional options.
type seasonOption func(*SeasonMutation)

// newSeasonMutation creates new mutation for the Season entity.
func newSeasonMutation(c config, op Op, opts ...seasonOption) *SeasonMutation {
	m := &SeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeasonID sets the ID field of the mutation.
func withSeasonID(id int) seasonOption {
	return func(m *SeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *Season
		)
		m.oldValue = func(ctx context.Context) (*Season, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Season.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeason sets the old Season of the mutation.
func withSeason(node *Season) seasonOption {
	return func(m *SeasonMutation) {
		m.oldValue = func(context.Context) (*Season, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Season.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeasonID sets the "season_id" field.
func (m *SeasonMutation) SetSeasonID(s string) {
	m.season_id = &s
}

// SeasonID returns the value of the "season_id" field in the mutation.
func (m *SeasonMutation) SeasonID() (r string, exists bool) {
	v := m.season_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonID returns the old "season_id" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSeasonID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonID: %w", err)
	}
	return oldValue.SeasonID, nil
}

// ResetSeasonID resets all changes to the "season_id" field.
func (m *SeasonMutation) ResetSeasonID() {
	m.season_id = nil
}

// SetSeasonTitle sets the "season_title" field.
func (m *SeasonMutation) SetSeasonTitle(s string) {
	m.season_title = &s
}

// SeasonTitle returns the value of the "season_title" field in the mutation.
func (m *SeasonMutation) SeasonTitle() (r string, exists bool) {
	v := m.season_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonTitle returns the old "season_title" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSeasonTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonTitle: %w", err)
	}
	return oldValue.SeasonTitle, nil
}

// ResetSeasonTitle resets all changes to the "season_title" field.
func (m *SeasonMutation) ResetSeasonTitle() {
	m.season_title = nil
}

// SetSeasonTitleYomi sets the "season_title_yomi" field.
func (m *SeasonMutation) SetSeasonTitleYomi(s string) {
	m.season_title_yomi = &s
}

// SeasonTitleYomi returns the value of the "season_title_yomi" field in the mutation.
func (m *SeasonMutation) SeasonTitleYomi() (r string, exists bool) {
	v := m.season_title_yomi
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonTitleYomi returns the old "season_title_yomi" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSeasonTitleYomi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonTitleYomi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonTitleYomi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonTitleYomi: %w", err)
	}
	return oldValue.SeasonTitleYomi, nil
}

// ClearSeasonTitleYomi clears the value of the "season_title_yomi" field.
func (m *SeasonMutation) ClearSeasonTitleYomi() {
	m.season_title_yomi = nil
	m.clearedFields[season.FieldSeasonTitleYomi] = struct{}{}
}

// SeasonTitleYomiCleared returns if the "season_title_yomi" field was cleared in this mutation.
func (m *SeasonMutation) SeasonTitleYomiCleared() bool {
	_, ok := m.clearedFields[season.FieldSeasonTitleYomi]
	return ok
}

// ResetSeasonTitleYomi resets all changes to the "season_title_yomi" field.
func (m *SeasonMutation) ResetSeasonTitleYomi() {
	m.season_title_yomi = nil
	delete(m.clearedFields, season.FieldSeasonTitleYomi)
}

// SetSeasonNumber sets the "season_number" field.
func (m *SeasonMutation) SetSeasonNumber(i int) {
	m.season_number = &i
	m.addseason_number = nil
}

// SeasonNumber returns the value of the "season_number" field in the mutation.
func (m *SeasonMutation) SeasonNumber() (r int, exists bool) {
	v := m.season_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonNumber returns the old "season_number" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSeasonNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonNumber: %w", err)
	}
	return oldValue.SeasonNumber, nil
}

// AddSeasonNumber adds i to the "season_number" field.
func (m *SeasonMutation) AddSeasonNumber(i int) {
	if m.addseason_number != nil {
		*m.addseason_number += i
	} else {
		m.addseason_number = &i
	}
}

// AddedSeasonNumber returns the value that was added to the "season_number" field in this mutation.
func (m *SeasonMutation) AddedSeasonNumber() (r int, exists bool) {
	v := m.addseason_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeasonNumber resets all changes to the "season_number" field.
func (m *SeasonMutation) ResetSeasonNumber() {
	m.season_number = nil
	m.addseason_number = nil
}

// SetShoboiTid sets the "shoboi_tid" field.
func (m *SeasonMutation) SetShoboiTid(i int) {
	m.shoboi_tid = &i
	m.addshoboi_tid = nil
}

// ShoboiTid returns the value of the "shoboi_tid" field in the mutation.
func (m *SeasonMutation) ShoboiTid() (r int, exists bool) {
	v := m.shoboi_tid
	if v == nil {
		return
	}
	return *v, true
}

// OldShoboiTid returns the old "shoboi_tid" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldShoboiTid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShoboiTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShoboiTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShoboiTid: %w", err)
	}
	return oldValue.ShoboiTid, nil
}

// AddShoboiTid adds i to the "shoboi_tid" field.
func (m *SeasonMutation) AddShoboiTid(i int) {
	if m.addshoboi_tid != nil {
		*m.addshoboi_tid += i
	} else {
		m.addshoboi_tid = &i
	}
}

// AddedShoboiTid returns the value that was added to the "shoboi_tid" field in this mutation.
func (m *SeasonMutation) AddedShoboiTid() (r int, exists bool) {
	v := m.addshoboi_tid
	if v == nil {
		return
	}
	return *v, true
}

// ClearShoboiTid clears the value of the "shoboi_tid" field.
func (m *SeasonMutation) ClearShoboiTid() {
	m.shoboi_tid = nil
	m.addshoboi_tid = nil
	m.clearedFields[season.FieldShoboiTid] = struct{}{}
}

// ShoboiTidCleared returns if the "shoboi_tid" field was cleared in this mutation.
func (m *SeasonMutation) ShoboiTidCleared() bool {
	_, ok := m.clearedFields[season.FieldShoboiTid]
	return ok
}

// ResetShoboiTid resets all changes to the "shoboi_tid" field.
func (m *SeasonMutation) ResetShoboiTid() {
	m.shoboi_tid = nil
	m.addshoboi_tid = nil
	delete(m.clearedFields, season.FieldShoboiTid)
}

// SetDescription sets the "description" field.
func (m *SeasonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SeasonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SeasonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[season.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SeasonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[season.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SeasonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, season.FieldDescription)
}

// SetFirstYear sets the "first_year" field.
func (m *SeasonMutation) SetFirstYear(i int) {
	m.first_year = &i
	m.addfirst_year = nil
}

// FirstYear returns the value of the "first_year" field in the mutation.
func (m *SeasonMutation) FirstYear() (r int, exists bool) {
	v := m.first_year
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstYear returns the old "first_year" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldFirstYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstYear: %w", err)
	}
	return oldValue.FirstYear, nil
}

// AddFirstYear adds i to the "first_year" field.
func (m *SeasonMutation) AddFirstYear(i int) {
	if m.addfirst_year != nil {
		*m.addfirst_year += i
	} else {
		m.addfirst_year = &i
	}
}

// AddedFirstYear returns the value that was added to the "first_year" field in this mutation.
func (m *SeasonMutation) AddedFirstYear() (r int, exists bool) {
	v := m.addfirst_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstYear clears the value of the "first_year" field.
func (m *SeasonMutation) ClearFirstYear() {
	m.first_year = nil
	m.addfirst_year = nil
	m.clearedFields[season.FieldFirstYear] = struct{}{}
}

// FirstYearCleared returns if the "first_year" field was cleared in this mutation.
func (m *SeasonMutation) FirstYearCleared() bool {
	_, ok := m.clearedFields[season.FieldFirstYear]
	return ok
}

// ResetFirstYear resets all changes to the "first_year" field.
func (m *SeasonMutation) ResetFirstYear() {
	m.first_year = nil
	m.addfirst_year = nil
	delete(m.clearedFields, season.FieldFirstYear)
}

// SetFirstMonth sets the "first_month" field.
func (m *SeasonMutation) SetFirstMonth(i int) {
	m.first_month = &i
	m.addfirst_month = nil
}

// FirstMonth returns the value of the "first_month" field in the mutation.
func (m *SeasonMutation) FirstMonth() (r int, exists bool) {
	v := m.first_month
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstMonth returns the old "first_month" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldFirstMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstMonth: %w", err)
	}
	return oldValue.FirstMonth, nil
}

// AddFirstMonth adds i to the "first_month" field.
func (m *SeasonMutation) AddFirstMonth(i int) {
	if m.addfirst_month != nil {
		*m.addfirst_month += i
	} else {
		m.addfirst_month = &i
	}
}

// AddedFirstMonth returns the value that was added to the "first_month" field in this mutation.
func (m *SeasonMutation) AddedFirstMonth() (r int, exists bool) {
	v := m.addfirst_month
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstMonth clears the value of the "first_month" field.
func (m *SeasonMutation) ClearFirstMonth() {
	m.first_month = nil
	m.addfirst_month = nil
	m.clearedFields[season.FieldFirstMonth] = struct{}{}
}

// FirstMonthCleared returns if the "first_month" field was cleared in this mutation.
func (m *SeasonMutation) FirstMonthCleared() bool {
	_, ok := m.clearedFields[season.FieldFirstMonth]
	return ok
}

// ResetFirstMonth resets all changes to the "first_month" field.
func (m *SeasonMutation) ResetFirstMonth() {
	m.first_month = nil
	m.addfirst_month = nil
	delete(m.clearedFields, season.FieldFirstMonth)
}

// SetFirstEndYear sets the "first_end_year" field.
func (m *SeasonMutation) SetFirstEndYear(i int) {
	m.first_end_year = &i
	m.addfirst_end_year = nil
}

// FirstEndYear returns the value of the "first_end_year" field in the mutation.
func (m *SeasonMutation) FirstEndYear() (r int, exists bool) {
	v := m.first_end_year
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstEndYear returns the old "first_end_year" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldFirstEndYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstEndYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstEndYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstEndYear: %w", err)
	}
	return oldValue.FirstEndYear, nil
}

// AddFirstEndYear adds i to the "first_end_year" field.
func (m *SeasonMutation) AddFirstEndYear(i int) {
	if m.addfirst_end_year != nil {
		*m.addfirst_end_year += i
	} else {
		m.addfirst_end_year = &i
	}
}

// AddedFirstEndYear returns the value that was added to the "first_end_year" field in this mutation.
func (m *SeasonMutation) AddedFirstEndYear() (r int, exists bool) {
	v := m.addfirst_end_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstEndYear clears the value of the "first_end_year" field.
func (m *SeasonMutation) ClearFirstEndYear() {
	m.first_end_year = nil
	m.addfirst_end_year = nil
	m.clearedFields[season.FieldFirstEndYear] = struct{}{}
}

// FirstEndYearCleared returns if the "first_end_year" field was cleared in this mutation.
func (m *SeasonMutation) FirstEndYearCleared() bool {
	_, ok := m.clearedFields[season.FieldFirstEndYear]
	return ok
}

// ResetFirstEndYear resets all changes to the "first_end_year" field.
func (m *SeasonMutation) ResetFirstEndYear() {
	m.first_end_year = nil
	m.addfirst_end_year = nil
	delete(m.clearedFields, season.FieldFirstEndYear)
}

// SetFirstEndMonth sets the "first_end_month" field.
func (m *SeasonMutation) SetFirstEndMonth(i int) {
	m.first_end_month = &i
	m.addfirst_end_month = nil
}

// FirstEndMonth returns the value of the "first_end_month" field in the mutation.
func (m *SeasonMutation) FirstEndMonth() (r int, exists bool) {
	v := m.first_end_month
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstEndMonth returns the old "first_end_month" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldFirstEndMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstEndMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstEndMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstEndMonth: %w", err)
	}
	return oldValue.FirstEndMonth, nil
}

// AddFirstEndMonth adds i to the "first_end_month" field.
func (m *SeasonMutation) AddFirstEndMonth(i int) {
	if m.addfirst_end_month != nil {
		*m.addfirst_end_month += i
	} else {
		m.addfirst_end_month = &i
	}
}

// AddedFirstEndMonth returns the value that was added to the "first_end_month" field in this mutation.
func (m *SeasonMutation) AddedFirstEndMonth() (r int, exists bool) {
	v := m.addfirst_end_month
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstEndMonth clears the value of the "first_end_month" field.
func (m *SeasonMutation) ClearFirstEndMonth() {
	m.first_end_month = nil
	m.addfirst_end_month = nil
	m.clearedFields[season.FieldFirstEndMonth] = struct{}{}
}

// FirstEndMonthCleared returns if the "first_end_month" field was cleared in this mutation.
func (m *SeasonMutation) FirstEndMonthCleared() bool {
	_, ok := m.clearedFields[season.FieldFirstEndMonth]
	return ok
}

// ResetFirstEndMonth resets all changes to the "first_end_month" field.
func (m *SeasonMutation) ResetFirstEndMonth() {
	m.first_end_month = nil
	m.addfirst_end_month = nil
	delete(m.clearedFields, season.FieldFirstEndMonth)
}

// SetSeriesID sets the "series" edge to the Series entity by id.
func (m *SeasonMutation) SetSeriesID(id int) {
	m.series = &id
}

// ClearSeries clears the "series" edge to the Series entity.
func (m *SeasonMutation) ClearSeries() {
	m.clearedseries = true
}

// SeriesCleared reports if the "series" edge to the Series entity was cleared.
func (m *SeasonMutation) SeriesCleared() bool {
	return m.clearedseries
}

// SeriesID returns the "series" edge ID in the mutation.
func (m *SeasonMutation) SeriesID() (id int, exists bool) {
	if m.series != nil {
		return *m.series, true
	}
	return
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *SeasonMutation) SeriesIDs() (ids []int) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *SeasonMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// AddEpisodeIDs adds the "episodes" edge to the Episode entity by ids.
func (m *SeasonMutation) AddEpisodeIDs(ids ...int) {
	if m.episodes == nil {
		m.episodes = make(map[int]struct{})
	}
	for i := range ids {
		m.episodes[ids[i]] = struct{}{}
	}
}

// ClearEpisodes clears the "episodes" edge to the Episode entity.
func (m *SeasonMutation) ClearEpisodes() {
	m.clearedepisodes = true
}

// EpisodesCleared reports if the "episodes" edge to the Episode entity was cleared.
func (m *SeasonMutation) EpisodesCleared() bool {
	return m.clearedepisodes
}

// RemoveEpisodeIDs removes the "episodes" edge to the Episode entity by IDs.
func (m *SeasonMutation) RemoveEpisodeIDs(ids ...int) {
	if m.removedepisodes == nil {
		m.removedepisodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.episodes, ids[i])
		m.removedepisodes[ids[i]] = struct{}{}
	}
}

// RemovedEpisodes returns the removed IDs of the "episodes" edge to the Episode entity.
func (m *SeasonMutation) RemovedEpisodesIDs() (ids []int) {
	for id := range m.removedepisodes {
		ids = append(ids, id)
	}
	return
}

// EpisodesIDs returns the "episodes" edge IDs in the mutation.
func (m *SeasonMutation) EpisodesIDs() (ids []int) {
	for id := range m.episodes {
		ids = append(ids, id)
	}
	return
}

// ResetEpisodes resets all changes to the "episodes" edge.
func (m *SeasonMutation) ResetEpisodes() {
	m.episodes = nil
	m.clearedepisodes = false
	m.removedepisodes = nil
}

// Where appends a list predicates to the SeasonMutation builder.
func (m *SeasonMutation) Where(ps ...predicate.Season) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Season, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Season).
func (m *SeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeasonMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.season_id != nil {
		fields = append(fields, season.FieldSeasonID)
	}
	if m.season_title != nil {
		fields = append(fields, season.FieldSeasonTitle)
	}
	if m.season_title_yomi != nil {
		fields = append(fields, season.FieldSeasonTitleYomi)
	}
	if m.season_number != nil {
		fields = append(fields, season.FieldSeasonNumber)
	}
	if m.shoboi_tid != nil {
		fields = append(fields, season.FieldShoboiTid)
	}
	if m.description != nil {
		fields = append(fields, season.FieldDescription)
	}
	if m.first_year != nil {
		fields = append(fields, season.FieldFirstYear)
	}
	if m.first_month != nil {
		fields = append(fields, season.FieldFirstMonth)
	}
	if m.first_end_year != nil {
		fields = append(fields, season.FieldFirstEndYear)
	}
	if m.first_end_month != nil {
		fields = append(fields, season.FieldFirstEndMonth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSeasonID:
		return m.SeasonID()
	case season.FieldSeasonTitle:
		return m.SeasonTitle()
	case season.FieldSeasonTitleYomi:
		return m.SeasonTitleYomi()
	case season.FieldSeasonNumber:
		return m.SeasonNumber()
	case season.FieldShoboiTid:
		return m.ShoboiTid()
	case season.FieldDescription:
		return m.Description()
	case season.FieldFirstYear:
		return m.FirstYear()
	case season.FieldFirstMonth:
		return m.FirstMonth()
	case season.FieldFirstEndYear:
		return m.FirstEndYear()
	case season.FieldFirstEndMonth:
		return m.FirstEndMonth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case season.FieldSeasonID:
		return m.OldSeasonID(ctx)
	case season.FieldSeasonTitle:
		return m.OldSeasonTitle(ctx)
	case season.FieldSeasonTitleYomi:
		return m.OldSeasonTitleYomi(ctx)
	case season.FieldSeasonNumber:
		return m.OldSeasonNumber(ctx)
	case season.FieldShoboiTid:
		return m.OldShoboiTid(ctx)
	case season.FieldDescription:
		return m.OldDescription(ctx)
	case season.FieldFirstYear:
		return m.OldFirstYear(ctx)
	case season.FieldFirstMonth:
		return m.OldFirstMonth(ctx)
	case season.FieldFirstEndYear:
		return m.OldFirstEndYear(ctx)
	case season.FieldFirstEndMonth:
		return m.OldFirstEndMonth(ctx)
	}
	return nil, fmt.Errorf("unknown Season field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case season.FieldSeasonID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonID(v)
		return nil
	case season.FieldSeasonTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonTitle(v)
		return nil
	case season.FieldSeasonTitleYomi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonTitleYomi(v)
		return nil
	case season.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonNumber(v)
		return nil
	case season.FieldShoboiTid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShoboiTid(v)
		return nil
	case season.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case season.FieldFirstYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstYear(v)
		return nil
	case season.FieldFirstMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstMonth(v)
		return nil
	case season.FieldFirstEndYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstEndYear(v)
		return nil
	case season.FieldFirstEndMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstEndMonth(v)
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeasonMutation) AddedFields() []string {
	var fields []string
	if m.addseason_number != nil {
		fields = append(fields, season.FieldSeasonNumber)
	}
	if m.addshoboi_tid != nil {
		fields = append(fields, season.FieldShoboiTid)
	}
	if m.addfirst_year != nil {
		fields = append(fields, season.FieldFirstYear)
	}
	if m.addfirst_month != nil {
		fields = append(fields, season.FieldFirstMonth)
	}
	if m.addfirst_end_year != nil {
		fields = append(fields, season.FieldFirstEndYear)
	}
	if m.addfirst_end_month != nil {
		fields = append(fields, season.FieldFirstEndMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSeasonNumber:
		return m.AddedSeasonNumber()
	case season.FieldShoboiTid:
		return m.AddedShoboiTid()
	case season.FieldFirstYear:
		return m.AddedFirstYear()
	case season.FieldFirstMonth:
		return m.AddedFirstMonth()
	case season.FieldFirstEndYear:
		return m.AddedFirstEndYear()
	case season.FieldFirstEndMonth:
		return m.AddedFirstEndMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case season.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeasonNumber(v)
		return nil
	case season.FieldShoboiTid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShoboiTid(v)
		return nil
	case season.FieldFirstYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstYear(v)
		return nil
	case season.FieldFirstMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstMonth(v)
		return nil
	case season.FieldFirstEndYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstEndYear(v)
		return nil
	case season.FieldFirstEndMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstEndMonth(v)
		return nil
	}
	return fmt.Errorf("unknown Season numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(season.FieldSeasonTitleYomi) {
		fields = append(fields, season.FieldSeasonTitleYomi)
	}
	if m.FieldCleared(season.FieldShoboiTid) {
		fields = append(fields, season.FieldShoboiTid)
	}
	if m.FieldCleared(season.FieldDescription) {
		fields = append(fields, season.FieldDescription)
	}
	if m.FieldCleared(season.FieldFirstYear) {
		fields = append(fields, season.FieldFirstYear)
	}
	if m.FieldCleared(season.FieldFirstMonth) {
		fields = append(fields, season.FieldFirstMonth)
	}
	if m.FieldCleared(season.FieldFirstEndYear) {
		fields = append(fields, season.FieldFirstEndYear)
	}
	if m.FieldCleared(season.FieldFirstEndMonth) {
		fields = append(fields, season.FieldFirstEndMonth)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeasonMutation) ClearField(name string) error {
	switch name {
	case season.FieldSeasonTitleYomi:
		m.ClearSeasonTitleYomi()
		return nil
	case season.FieldShoboiTid:
		m.ClearShoboiTid()
		return nil
	case season.FieldDescription:
		m.ClearDescription()
		return nil
	case season.FieldFirstYear:
		m.ClearFirstYear()
		return nil
	case season.FieldFirstMonth:
		m.ClearFirstMonth()
		return nil
	case season.FieldFirstEndYear:
		m.ClearFirstEndYear()
		return nil
	case season.FieldFirstEndMonth:
		m.ClearFirstEndMonth()
		return nil
	}
	return fmt.Errorf("unknown Season nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeasonMutation) ResetField(name string) error {
	switch name {
	case season.FieldSeasonID:
		m.ResetSeasonID()
		return nil
	case season.FieldSeasonTitle:
		m.ResetSeasonTitle()
		return nil
	case season.FieldSeasonTitleYomi:
		m.ResetSeasonTitleYomi()
		return nil
	case season.FieldSeasonNumber:
		m.ResetSeasonNumber()
		return nil
	case season.FieldShoboiTid:
		m.ResetShoboiTid()
		return nil
	case season.FieldDescription:
		m.ResetDescription()
		return nil
	case season.FieldFirstYear:
		m.ResetFirstYear()
		return nil
	case season.FieldFirstMonth:
		m.ResetFirstMonth()
		return nil
	case season.FieldFirstEndYear:
		m.ResetFirstEndYear()
		return nil
	case season.FieldFirstEndMonth:
		m.ResetFirstEndMonth()
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.series != nil {
		edges = append(edges, season.EdgeSeries)
	}
	if m.episodes != nil {
		edges = append(edges, season.EdgeEpisodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	case season.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.episodes))
		for id := range m.episodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedepisodes != nil {
		edges = append(edges, season.EdgeEpisodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.removedepisodes))
		for id := range m.removedepisodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedseries {
		edges = append(edges, season.EdgeSeries)
	}
	if m.clearedepisodes {
		edges = append(edges, season.EdgeEpisodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case season.EdgeSeries:
		return m.clearedseries
	case season.EdgeEpisodes:
		return m.clearedepisodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeasonMutation) ClearEdge(name string) error {
	switch name {
	case season.EdgeSeries:
		m.ClearSeries()
		return nil
	}
	return fmt.Errorf("unknown Season unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeasonMutation) ResetEdge(name string) error {
	switch name {
	case season.EdgeSeries:
		m.ResetSeries()
		return nil
	case season.EdgeEpisodes:
		m.ResetEpisodes()
		return nil
	}
	return fmt.Errorf("unknown Season edge %s", name)
}

// SeriesMutation represents an operation that mutates the Series nodes in the graph.
type SeriesMutation struct {
	config
	op             Op
	typ            string
	id             *int
	series_id      *string
	title          *string
	title_yomi     *string
	clearedFields  map[string]struct{}
	seasons        map[int]struct{}
	removedseasons map[int]struct{}
	clearedseasons bool
	done           bool
	oldValue       func(context.Context) (*Series, error)
	predicates     []predicate.Series
}

var _ ent.Mutation = (*SeriesMutation)(nil)

// seriesOption allows management of the mutation configuration using functional options.
type seriesOption func(*SeriesMutation)

// newSeriesMutation creates new mutation for the Series entity.
func newSeriesMutation(c config, op Op, opts ...seriesOption) *SeriesMutation {
	m := &SeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriesID sets the ID field of the mutation.
func withSeriesID(id int) seriesOption {
	return func(m *SeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *Series
		)
		m.oldValue = func(ctx context.Context) (*Series, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Series.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeries sets the old Series of the mutation.
func withSeries(node *Series) seriesOption {
	return func(m *SeriesMutation) {
		m.oldValue = func(context.Context) (*Series, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Series.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriesID sets the "series_id" field.
func (m *SeriesMutation) SetSeriesID(s string) {
	m.series_id = &s
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *SeriesMutation) SeriesID() (r string, exists bool) {
	v := m.series_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldSeriesID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *SeriesMutation) ResetSeriesID() {
	m.series_id = nil
}

// SetTitle sets the "title" field.
func (m *SeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SeriesMutation) ResetTitle() {
	m.title = nil
}

// SetTitleYomi sets the "title_yomi" field.
func (m *SeriesMutation) SetTitleYomi(s string) {
	m.title_yomi = &s
}

// TitleYomi returns the value of the "title_yomi" field in the mutation.
func (m *SeriesMutation) TitleYomi() (r string, exists bool) {
	v := m.title_yomi
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleYomi returns the old "title_yomi" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldTitleYomi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleYomi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleYomi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleYomi: %w", err)
	}
	return oldValue.TitleYomi, nil
}

// ClearTitleYomi clears the value of the "title_yomi" field.
func (m *SeriesMutation) ClearTitleYomi() {
	m.title_yomi = nil
	m.clearedFields[series.FieldTitleYomi] = struct{}{}
}

// TitleYomiCleared returns if the "title_yomi" field was cleared in this mutation.
func (m *SeriesMutation) TitleYomiCleared() bool {
	_, ok := m.clearedFields[series.FieldTitleYomi]
	return ok
}

// ResetTitleYomi resets all changes to the "title_yomi" field.
func (m *SeriesMutation) ResetTitleYomi() {
	m.title_yomi = nil
	delete(m.clearedFields, series.FieldTitleYomi)
}

// AddSeasonIDs adds the "seasons" edge to the Season entity by ids.
func (m *SeriesMutation) AddSeasonIDs(ids ...int) {
	if m.seasons == nil {
		m.seasons = make(map[int]struct{})
	}
	for i := range ids {
		m.seasons[ids[i]] = struct{}{}
	}
}

// ClearSeasons clears the "seasons" edge to the Season entity.
func (m *SeriesMutation) ClearSeasons() {
	m.clearedseasons = true
}

// SeasonsCleared reports if the "seasons" edge to the Season entity was cleared.
func (m *SeriesMutation) SeasonsCleared() bool {
	return m.clearedseasons
}

// RemoveSeasonIDs removes the "seasons" edge to the Season entity by IDs.
func (m *SeriesMutation) RemoveSeasonIDs(ids ...int) {
	if m.removedseasons == nil {
		m.removedseasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seasons, ids[i])
		m.removedseasons[ids[i]] = struct{}{}
	}
}

// RemovedSeasons returns the removed IDs of the "seasons" edge to the Season entity.
func (m *SeriesMutation) RemovedSeasonsIDs() (ids []int) {
	for id := range m.removedseasons {
		ids = append(ids, id)
	}
	return
}

// SeasonsIDs returns the "seasons" edge IDs in the mutation.
func (m *SeriesMutation) SeasonsIDs() (ids []int) {
	for id := range m.seasons {
		ids = append(ids, id)
	}
	return
}

// ResetSeasons resets all changes to the "seasons" edge.
func (m *SeriesMutation) ResetSeasons() {
	m.seasons = nil
	m.clearedseasons = false
	m.removedseasons = nil
}

// Where appends a list predicates to the SeriesMutation builder.
func (m *SeriesMutation) Where(ps ...predicate.Series) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Series, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Series).
func (m *SeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.series_id != nil {
		fields = append(fields, series.FieldSeriesID)
	}
	if m.title != nil {
		fields = append(fields, series.FieldTitle)
	}
	if m.title_yomi != nil {
		fields = append(fields, series.FieldTitleYomi)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case series.FieldSeriesID:
		return m.SeriesID()
	case series.FieldTitle:
		return m.Title()
	case series.FieldTitleYomi:
		return m.TitleYomi()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case series.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case series.FieldTitle:
		return m.OldTitle(ctx)
	case series.FieldTitleYomi:
		return m.OldTitleYomi(ctx)
	}
	return nil, fmt.Errorf("unknown Series field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case series.FieldSeriesID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case series.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case series.FieldTitleYomi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleYomi(v)
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Series numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(series.FieldTitleYomi) {
		fields = append(fields, series.FieldTitleYomi)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriesMutation) ClearField(name string) error {
	switch name {
	case series.FieldTitleYomi:
		m.ClearTitleYomi()
		return nil
	}
	return fmt.Errorf("unknown Series nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriesMutation) ResetField(name string) error {
	switch name {
	case series.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case series.FieldTitle:
		m.ResetTitle()
		return nil
	case series.FieldTitleYomi:
		m.ResetTitleYomi()
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.seasons != nil {
		edges = append(edges, series.EdgeSeasons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeSeasons:
		ids := make([]ent.Value, 0, len(m.seasons))
		for id := range m.seasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedseasons != nil {
		edges = append(edges, series.EdgeSeasons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeSeasons:
		ids := make([]ent.Value, 0, len(m.removedseasons))
		for id := range m.removedseasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseasons {
		edges = append(edges, series.EdgeSeasons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case series.EdgeSeasons:
		return m.clearedseasons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Series unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriesMutation) ResetEdge(name string) error {
	switch name {
	case series.EdgeSeasons:
		m.ResetSeasons()
		return nil
	}
	return fmt.Errorf("unknown Series edge %s", name)
}
